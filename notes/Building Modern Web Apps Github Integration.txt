# Building Modern Web Apps (Github Integration)

## OAuth Explained

OAuth is an authentication service that handles logins or other information using third-party APIs. It asks for permissions, then returns a token (after authenticating with *you*) that you use to login/access the information.

1. Ask API for permission code
2. Get back a code
3. Send back the code (use GET request to get token)
4. Get back a login token
5. Save token

## Login Route

1. Ask API for permission code

We're using the Github API for OAuth, also using **qs** to parse and encode URLs.

First we create a route for login in the routes object. 

```
routes: {
	// name : // corresponding handler fn
	'': 'public',
	'repos': 'repos',
	'login': 'login'
},
```

Then we create a login handler fn to handle the API request. We pass three parameters:

```
login () {
	window.location = 'https://github.com/login/oauth/authorize?' + qs.stringify({
	  scope: 'user,repo',
	  redirect_uri: window.location.origin + '/auth/callback',
	  client_id: 'f8dd69187841cdd22a26'
	});
}
```

Above the `redirect_uri` uses `window.location.origin`. If we did this anywhere in `github.com` it would return `http://github.com/`. It's the original root of the site.

## Auth-Callback Route

2. Get back a code

Let's create another route to get this query:

```
routes: {
	…
	'auth/callback?:query': 'authCallback'
},
```

In the above route we can get parameters by using the `?:query` in the route handler. Now let's define authCallback.

3. Send back the code (use GET request to get token)
4. Get back the login token

We're using [Gatekeeper](https://github.com/prose/gatekeeper), which let's use configuration secrets in client-side applications using Heroku. We've setup [labelr.herokuapp](http://labelr-localhost.herokuapp.com/authenticate/CODE) to receive tokens. We're going to use [XHR](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest) to transfer data from the client to the server.

```
authCallback (query) {
  query = qs.parse(query)

  xhr({
    // we're inputting our client secret in heroku
    // allowing us to hide our client_secret
    url: 'https://labelr-localhost.herokuapp.com/authenticate/' + query.code,
    json: true
  }, (err, req, body) => {
    console.log(body)
  })
}
```

If you see xhr above, that is processing our HTTP request.

Tip 1: The above `=>` is ES6 syntax. This is the equivalent of `function() { … }.bind(this)`.
Tip 2: Always handle authorization through `https`

## Persisting the Login

5. Save token

We want to save this login. We can create a model so we can add a session to the browser.

```
/* model/me.js */
import Model from 'ampersand-model'

export default Model.extend({
  initialize () {
		// localStorage is a lot safer in React
    this.token = window.localStorage.token

    this.on('change:token', this.onTokenChange)
  },

  props: {
    id: 'number',
    login: 'string',
    avatar_url: 'string'
  },

  session: {
    token: 'string'
  },

  onTokenChange () {
    window.localStorage.token = this.token  
  }
})
```

localStorage is safer in React because it handles the DOM manipulation. You'll have more trouble creating a script tag.

Let's fire this off when the HTTP request returns:

```
xhr({
	…
}, (err, req, body) => {
  app.me.token = body.token
  // replaces the history using internal navigation
  this.redirectTo('/repos')
})
```

Finally let's update the app init:

```
app.extend({
  init () {
    this.me = new Me()
    this.router = new Router()
    this.router.history.start()
  }
})
```

## Logging Out

A UX/security issue is that if you log out using OAuth, you can simply click login and it will get a new token. When you log out of your app, you're logging out of *your* app.

So let's point something to `/logout`, and assign the route to a handler that clears the session:

```
routes: {
	…
	'logout': 'logout'
}
logout () {
	window.localStorage.clear()
	window.location = '/'
}
```

## Fetching User Data

We're now going to extend the Me model:

```
export default Model.extend({
  url: 'https://api.github.com/user',

  initialize () {
    this.token = window.localStorage.token
    this.on('change:token', this.onTokenChange)
  },

  props: {
    id: 'number',
    login: 'string',
    avatar_url: 'string'
  },

  session: {
    token: 'string'
  },

  onTokenChange () {
    window.localStorage.token = this.token  
    this.fetchInitialData()
  },

  ajaxConfig () {
    return {
      headers: {
        Authorization: 'token ' + this.token
      }
    }
  },

  fetchInitialData () {
    if (this.token) {
      this.fetch()
    }
  }
})
```

Many of the above are aided by [ampersand-model](https://ampersandjs.com/docs/#ampersand-model-url). 

Again, we're going to update the app init:

```
app.extend({
  init () {
    this.me = new Me()
    this.me.fetchInitialData()
    this.router = new Router()
    this.router.history.start()
  }
})
```

## Binding to a Model

We're going to use a mixin to watch for "props" passed in the layout using `ampersand-react-mixin`. If a change in the model is detected, the render method of the component will be called. 

This let's us make changes on the layout as new data is passed in, in this case rendering the user name after the data has been passed in.

```
/* layout.js */
…
import app from 'ampersand-app'
import ampersandMixin from 'ampersand-react-mixin'

export default React.createClass({
  mixins: [ampersandMixin],

  displayName: 'Layout',

	…
})
```

Now pass in the model to the layout:

```
<Layout me={app.me}>
  {page}
</Layout>
```

Tip 1: ES6 has a shorthand {prop} = this.parentProp. See example below:
```
// ES6 destructuring assignment
// local reference to this.props.me
const {me} = this.props
console.log(me.name)
```

### Lifecycle Methods

React has something called lifecycle methods, that executed at specific points in a component's lifecycle.

`ampersand-react-mixin` watches for updates to the component. If you give it a property that's a model, at the point a model property in the component changes, it will let the model know. 

You have registered actions at the application level and your data stores. Then you have a central dispatcher that fires events once. The data stores (models) listen for actions, and you get a single change event that fires an action.

## Collections and Mixins

We're creating two models now, repo and repo-collection.

A repo is an observable model, whereas the repo-collection is an observable array of models.

```
/* repo.js *.
import Model from 'ampersand-model'

export default Model.extend({

  // corresponds to Github API repo properties  
  props: {
    id: 'number',
    name: 'string',
    full_name: 'string'
  }
})
```

```
/* repo-collection.js */
import Collection from 'ampersand-rest-collection'
import Repo from './repo'

export default Collection.extend({
  url: 'https://api.github.com/user/repos',

  // pass single model into the collection
  model: Repo
})
```

Because we're beginning to reuse our ajaxConfig method for the Github auth token in `me.js`, we're separating that fn into a helper model. 

```
/* github-mixin.js */
import app from 'ampersand-app'

export default {

  ajaxConfig () {
    console.log(app.me.token)

    return {
      headers: {
				// no longer this.token
				// import app above to always use global token
        Authorization: 'token ' + app.me.token
      }
    }
  }
}
```

Now we need to include this into our `repo-collection.js` and `me.js`

```
import githubMixin from '../helpers/github-mixin'

export default Collection.extend(githubMixin, {
	…
}
```

```
import githubMixin from '../helpers/github-mixin'

export default Model.extend(githubMixin, {
…
}
```
## Fetching User Repos

We want to associate the repos with our Me model. We're going to connect that using the collections attribute.

```
/* me.js */
import RepoCollection from './repo-collection'
…
collections: {
	// associate repos with me model
	repos: RepoCollection
},
…
fetchInitialData () {
	if (this.token) {
	  // automatically fetch user and repos onload
	  this.fetch()
	  this.repos.fetch()
	}
}
```

